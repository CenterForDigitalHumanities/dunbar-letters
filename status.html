<!DOCTYPE html>
<html lang="en">

<head>
    <title>Dunbar Letters Status</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="stylesheet" href="css/gloss.css"> -->
    <link rel="stylesheet" href="css/status.css">
    <link href="favicon.ico" rel="icon" type="image/x-icon" />
    <style>

        .good{
            color: green;
        }

        .bad{
            color: red;
        }

        .statusLabel{

        }

        .tpenProjectStatus{

        }

        .tpenProjectStatusList{

        }

        #dla_browsable{
            display: none;
        }

        #tpen_browsable{
            margin-top: 1em;
            border-top: 3px solid green;
            border-left: 1px solid black;
            border-right: 1px solid black;
        }

        dt{
            width: auto;
        }

        .record{
            zoom:  75%;
        }

    </style>
</head>

<body class="container">
    <gm-header>
        <div class="tabs">
            <a href="./index.html">üè†</a>
            <a href="./manuscripts.html">üìö View Manuscripts</a>
            <a href="./ms.html" id="thisMS" class="is-hidden">üìñ This Manuscript</a>
        </div>
    </gm-header>

    <div class="itemStatusRenderingExample">
        <input type="button" value="TPEN Project Statuses" onclick="loadInterfaceTPEN()" />
        <input type="button" value="UDel Record Statuses" onclick="loadInterfaceDLA()" />
        <!-- <input type="button" value="Load Filterable Interface" onclick="loadInterface()" /> -->
        <!-- <div id="tpenProjectsStatusArea"> </div>
        <div id="dlaRecordsStatusArea"> </div> -->
    </div>

    <div id="dla_browsable" class="container reverse">
        <div id="DLADocuments" class="grow wrap">list loading</div>
        <div class="sidebar">
            <h3>Refine Results <button role="button" id="queryReset">clear all</button></h3>
            <progress value="107" max="107">107 of 107</progress>
            <input id="dla_query" type="text" placeholder="type to filter">
            <section id="dlaFacetFilter"></section>
        </div>
    </div>

    <div id="tpen_browsable" class="container reverse">
        <div id="TPENDocuments" class="grow wrap">list loading</div>
        <div class="sidebar">
            <h3>Refine Results <button role="button" id="queryReset">clear all</button></h3>
            <progress value="107" max="107">107 of 107</progress>
            <input id="tpen_query" type="text" placeholder="type to filter">
            <section id="tpenFacetFilter"></section>
        </div>
    </div>

    <gm-footer>
        <a href="./index.html">üè†</a>
        <a href="./manuscripts.html">üìö</a>
        <a rel="noopener noreferrer" title="View on GitHub" href="https://github.com/cubap/Dunbar-Letters"
            target="_blank">
            <svg height="16" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="16"
                aria-hidden="true">
                <path fill-rule="evenodd"
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                </path>
            </svg>
        </a>
    </gm-footer>
    
    <div id="globalFeedback" class="card is-center"></div>
    <script src="js/deer.js" type="module"></script>
    <script src="js/app.js" type="module"></script>
    <script>
        let tpenProjects = []
        let dlaCollection = []
        let tpenRecords = []
        let dlaRecords = []
        const udelHandlePrefix = "https://udspace.udel.edu/rest/handle/"
        const udelIdPrefix = "https://udspace.udel.edu/rest/items/"
        const tpenProjectPrefix = "http://t-pen.org/TPEN/project/"
        const TPproxy = "http://tinypaul.rerum.io/dla/proxy?url="
        let progress = undefined

        getTranscriptionProjects()
        fetchLetters()

        /**
         * Hey internet, I want the Dunbar Projects out of T-PEN.
         * */
        async function getTranscriptionProjects(){
            tpenProjects =  
            await fetch(`media/tpenShort.json`)
            //await fetch(`http://165.134.105.25:8181/TPEN28/getDunbarProjects`)
            .then(res=>res.ok?res.json():[])
            .then(projects=>{return projects})
            .catch(err=> {
                console.error(err)
                return []
            })
        }

        /**
         * Hey internet, I want the DLA items from Delaware.
         * */
        async function fetchLetters() {
            dlaCollection = await fetch(`media/udelShort.json`)
                .then(res => res.ok ? res.json() : [])
                .then(records => {return records})
                .catch(err=> {
                    console.error(err)
                    return []
                })
        }

        function broadcast(event = {}, type, element, obj = {}) {
            let e = new CustomEvent(type, { detail: Object.assign(obj, { target: event.target }), bubbles: true })
            element.dispatchEvent(e)
        }

        /**
         * Generate the HTML element which will represent the status passed in.  
         * This is for the T-PEN projects items.
         * */
        async function generateProjectStatusElement(status, proj){
            let el, statusString, Fcode = ""
            let linkingAnnos, describingAnnos = []
            //Each status handled as its own case.  If we are uniform in what we do we can make this part much shorter if we have a strategic statusesToFind
            switch (status){
                case "parsedStatus":
                    statusString = "<span class='statusString good'>Parsed</span>"
                    proj.pages.forEach(page => {
                        if(page.numParsedLines < 5){
                            statusString = "<span title='See "+page.page_name+"' class='statusString bad'>Not Parsed</span>"
                            return
                        }
                    })
                    el =
                    `<dt class="statusLabel" title="Check if there are more than 5 lines with width > 0"> TPEN Project Parsed </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `                               
                break
                case "assignedStatus":
                    statusString = `<span class='statusString bad'>Not Assigned</span>`
                    if(proj.assignees.length > 2){
                        statusString = `<span class='statusString good'>Assigned to ${proj.assignees.length} users </span>`
                    }
                    el =
                    `<dt class="statusLabel" title="Check if it is assigned to at least 1 user"> TPEN Project Assigned </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `   
                break
                case "transcribedStatus":
                    statusString = "<span class='statusString good'>Transcribed</span>"
                    proj.pages.forEach(page => {
                        //We really need to think about this one.
                        if(page.numTranscribedLines < 5){
                            statusString = "<span title='See "+page.page_name+"' class='statusString bad'>Not Transcribed</span>"
                            return
                        }
                    })
                    el =
                    `<dt class="statusLabel" title="Check if there are more than 5 lines with width > 0 that have text on each page"> TPEN Project Transcribed </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `   
                break
                case "finalizedStatus":
                    statusString = "<span class='statusString bad'>Not Finalized</span>"
                    if(proj.finalized === "true"){
                        statusString = "<span class='statusString good'>Finalized</span>"
                    }
                    el =
                    `<dt class="statusLabel" title="If there are more than 5 parsed lines on each page, and every line contains text.  Logic performed in servlet and returns T/F."> TPEN Project Finalized </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `   
                break
                case "TPENLinkStatus":
                    linkingAnnos = await fetchQuery({"type":"Annotation", "tpenProject":""+proj.id})
                    statusString = "<span class='statusString bad'>No Linked Record</span>"
                    if(linkingAnnos.length>0){
                        statusString = "<span class='statusString good'> "+linkingAnnos.length+" Linked Record(s)</span>"
                    }
                    el =
                    `<dt class="statusLabel" title=""> Linked to UDel Data </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `   
                break
                case "describedStatus":
                    //This T-PEN project would have to be linked to a UDEL record
                    //That linking annotation has a target
                    //If it is described, other annos will target that same target
                    //Check how many annos target, and define the good/bad threshold. 

                    //So there are some testing ones around.  Look for tpenProject.
                    linkingAnnos = await fetchQuery({"type":"Annotation", "tpenProject":""+proj.id})
                    describingAnnos = []
                    if(linkingAnnos.length > 0){
                        describingAnnos = await fetchQuery({"type":"Annotation", "target":linkingAnnos[0].target})
                    }
                    //Grabbing to anno.targets will tell you what handle
                    statusString = "<span class='statusString bad'>Not Described</span>"
                    if(describingAnnos.length>0){
                        statusString = "<span class='statusString good'>There are "+describingAnnos.length+" descriptive annotations</span>"
                    }
                    el =
                    `<dt class="statusLabel" title=""> Well Described </dt>
                     <dd class="statusValue">${statusString}</dd>
                    `   
                break
                default:
                    el=""
                    console.error("Uknown status "+status)
            }
            return el
        }

        /**
         * Generate the HTML element which will represent the status passed in.  
         * This is for the DLA items.
         * */
        async function generateDLAStatusElement(status, item){
            let statusString = ""
            switch (status){
                case "TPENProjectCreated":
                    //Can we match a T-PEN project to this record?
                    statusString = "<span class='statusString bad'>No TPEN Project Created</span>"
                    let found = await matchTranscriptionRecords(item)
                    if(found.length > 0){
                        statusString = "<span title='"+found.join()+"' class='statusString good'>"+found.length+" TPEN Projects Found</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> TPEN Transcription Project Created </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "TPENProjectLinked":
                    const tpenProjectKeyWildcard = {$exists: true, $type: 'string', $ne: ''}
                    statusString = "<span class='statusString bad'>No TPEN Link</span>"
                    let tpenProjectLinkingAnnos = await fetchQuery({"type":"Annotation", "target":udelHandlePrefix+item.handle, "body.tpenProject":tpenProjectKeyWildcard})
                    let tpenProjectIDs = []
                    if(tpenProjectLinkingAnnos.length > 0){
                        for(tpenAnno of tpenProjectLinkingAnnos){
                            tpenProjectIDs.push(tpenProjectLinkingAnnos.body.tpenProject)
                        }
                        statusString = "<span title='See "+tpenProjectIDs.join()+"' class='statusString good'>Found TPEN Project Link(s)</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> T-PEN Project Linked Status </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "envelopeLinked":
                    //This is probably a T-PEN check, not sure. Can we check for an annotation with body that is a certain name or a primitive name of some kind?
                    statusString = "<span class='statusString good'>Under Development!</span>"
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> Item Envelope </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "uDelLinked":
                    statusString = "<span class='statusString bad'>Record Not Linked</span>"
                    let recordHandleAnnos2 = await fetchQuery({"type":"Annotation", "body.source.value":udelHandlePrefix+item.handle})
                    if(recordHandleAnnos2.length > 0){
                        statusString = "<span title='See "+recordHandleAnnos2[0].target+"' class='statusString good'>Record Linked</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> RERUM Record Linked Status </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                default:
                    el=``
                    console.error("Uknown status "+status)
            }
            return el
        }

        /**
         * Loop through all DLA records and determine the following statuses:
         * "uDelLinked",
         * "TPENProjectCreated"
         * "TPENProjectLinked"
         * "envelopeLinked"
         * */
        async function determineStatusesAgainstDLARecords(){
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            const statusesToFind = [
                "uDelLinked",
                "TPENProjectCreated",
                "TPENProjectLinked",
                "envelopeLinked"
            ]
            let handle = dlaCollection.handle
            let collectionID = dlaCollection.id
            let collectionName = dlaCollection.name
            let numItems = dlaCollection?.items.length
            let dlaRecordsHeading = `<h2>${collectionName} Records</h2><p>There are ${numItems} records.  Here are their details.</p>`
            document.getElementById("dlaRecordsStatusArea").innerHTML += dlaRecordsHeading
            for (item of dlaCollection.items){
                let item_handle = item.handle
                let item_id = item.id
                let item_name = item.name
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateDLAStatusElement(status, item)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                //Can filter items by statuses in status-list
                let itemArea = `
                    <div class="dlaItemStatus" status-list="${statusListAttributes.join(' ')}">
                        <h3>${item_id+": "+item_name}</h3>
                        <ul class="dlaItemStatusList">${statusListElements}</ul>
                    </div>
                `
                document.getElementById("dlaRecordsStatusArea").innerHTML += itemArea
            }
        }

        /**
         * Loop through all the Dunbar T-PEN projects and determine the following statuses
         * "parsedStatus"
         * "assignedStatus"
         * "transcribedStatus"
         * "finalizedStatus"
         * "TPENLinkStatus"
         * "describedStatus"
         * */
        async function determineStatusesAgainstTPENProjects(){
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            const statusesToFind = [
                "parsedStatus",
                "assignedStatus",
                "transcribedStatus",
                "finalizedStatus",
                "TPENLinkStatus",
                "describedStatus"
            ]
            //Go over each TPEN project and figure out the status stats.
            let numItems = tpenProjects.length
            let dlaRecordsHeading = `<h2>Dunbar Projects in T-PEN</h2><p>There are ${numItems} records.  Here are their details.</p>`
            document.getElementById("tpenProjectsStatusArea").innerHTML += dlaRecordsHeading
            for(proj of tpenProjects){
                //Each thing will have this suite of statuses to check for
                //These are in the tpen objects
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateProjectStatusElement(status, proj)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                let projectArea = `
                    <div class="tpenProjectStatus" status-list="${statusListAttributes.join(' ')}">
                        <h3>${proj.id+": "+proj.project_name+" ("+proj.metadata_name+")"}</h3>
                        <ul class="tpenProjectStatusList">${statusListElements}</ul>
                    </div>
                `
                document.getElementById("tpenProjectsStatusArea").innerHTML += projectArea
            }
        }

        /**
         * Determine all statuses possible against the dataset, and put them together in a meaningful way.
         * */
        async function statuses(){
            console.warn("Not Yet :(")
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
        }


        /**
         * Perform a tiny query against the query parameter object passed in.
         * */
        async function fetchQuery(params){
            const historyWildcard = { $exists: true, $type: 'array', $eq: [] }
            let query = {
                "__rerum.history.next": historyWildcard
            }
            let queryObj = Object.assign(query, params)
            return fetch("http://tinydev.rerum.io/app/query", {
                method: 'POST',
                mode: 'cors',
                body: JSON.stringify(queryObj)
            })
            .then(res => res.ok ? res.json() : Promise.reject(res))
        }

        /**
         *  You have a DLA Item F-Code known from a project ID.  Get the DLA record(s) that have a matching F-Code in their metadata.
         * */
        async function findUdelRecordWithCode(Fcode, projID) {
            // This is the Fcode that the TPEN project knew, like F158
            // Need to check that there is a udel item with this Fcode, looking through letters collection.
            const getFolderFromMetadata = (metaMap) => {
                let ok = false
                for (const m of metaMap) {
                    if (m.key === "dc.identifier.other") { 
                        ok = true
                        return m.value 
                    }
                }
                if(!ok){
                    console.error("No dc.identifier.other in metadata")
                    console.log(metaMap)
                }
            }
            let match = false
            let impossible = false;
            let itemHandle = ""
            for(item of dlaCollection.items){
                const metadataUri = `http://tinypaul.rerum.io/dla/proxy?url=${udelHandlePrefix+item.handle}?expand=metadata`    
                match = await fetch(metadataUri)
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(meta => getFolderFromMetadata(meta.metadata))
                    .then(folderString => {
                        if(folderString !== undefined && folderString.indexOf(" F") > -1){
                            return folderString.split(" F").pop()
                        }
                        else{
                            //This DLA item does not have dc.identifier.other, so there is no connected Fcode
                            impossible = true
                            return ""
                        }
                    }) // Like "Box 3, F4"
                    .then(folderNumber => {
                        const matchStr = `F${folderNumber.padStart(3, '0')}`
                        return Fcode === matchStr
                    })
                if(match){
                    itemHandle = udelHandlePrefix+item.handle
                    return
                }    
                if(impossible){
                    console.error("Could not determine folder name for "+udelHandlePrefix+item.handle+"?expand=metadata.  That means this TPEN project "+projID+" cannot determine if a udel record exists for code "+Fcode+".  We are skipping the check for this project.")
                    return
                }
            }
            return itemHandle
        }

        /**
         * You have a DLA record.  You would like to see if any transcription projects are created that are about this record.
         * Note this does not detect that record and project(s) are specifically linked yet.
         * */
        async function matchTranscriptionRecords(dlaRecord) {
            const metadataUri = `http://tinypaul.rerum.io/dla/proxy?url=${udelHandlePrefix+dlaRecord.handle}?expand=metadata`
            return await fetch(metadataUri)
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(meta => getFolderFromMetadata(meta.metadata))
                .then(folderString => folderString.split(" F").pop()) // Like "Box 3, F4"
                .then(folderNumber => {
                    const matchStr = `F${folderNumber.padStart(3, '0')}`
                    let matches = []
                    for (const f of tpenProjects) {
                        if (f.collection_code === matchStr) { 
                            matches.push(f.id) 
                        }
                    }
                    return matches
                })
                .catch(err => {return []})
        }

        /**
         * Render a filterable scrollable area to go over the status of each DLA item or each  T-PEN project
         * or possibly a combinations. 
         * */
        async function loadInterfaceDLA() {
            let dlaAreaElem = document.getElementById("dla_browsable")
            let dlaItems = dlaCollection.items
            dlaAreaElem.innerHTML = `
                <div id="DLADocuments" class="grow wrap">list loading</div>
                <div class="sidebar">
                    <h3>Refine Results <button role="button" id="dlaQueryReset">clear all</button></h3>
                    <progress value="107" max="107">107 of 107</progress>
                    <input id="query" type="text" placeholder="type to filter">
                    <section id="dlaFacetFilter"></section>
                </div>
            `

            const DLA_FIELDS = [
                "Name", "Item Handle", "Item ID"
                //"Author", "Subjects", "Publisher", "Language", 
                //"Date Issued", "Box ID", "Number of Pages",
                //"Collection ID", "Unique ID"
                // script, decoration, physical description
            ]

            const DLA_FILTERS = {
                Status: "statuses"
            }


            const DLA_SEARCH =[
                "Title", "Physical Description", "Note(s)", "Region",
                "Topic", "Subject", "Repository", "Call Number", "Is Part Of"
            ]

            const statusesToFind = [
                "uDelLinked",
                "TPENProjectCreated",
                "TPENProjectLinked",
                "envelopeLinked"
            ]

            let listOfDLAItems = dlaItems.reduce(async function(a, b){
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateDLAStatusElement(status, b)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                a += `
                <div class="dlaRecord record" data-id="${TPproxy+udelIdPrefix+b.id}?expand=metadata" statuses="${statusListAttributes.join(' ')}">
                    <h4><a href="${udelIdPrefix+b.id}">${b.name}</a></h4>
                    <ul>
                        ${statusListElements}
                    </ul>
                </div>`}, ``)

            dlaAreaElem.innerHTML = listOfDLAItems

            dlaRecords = document.querySelectorAll(".dlaRecord")
            let dla_facets = {}
            let dla_loading = []

            Array.from(dlaRecords).forEach(r => {
                const url = r.getAttribute("data-id")
                let dl = ``
                dla_loading.push(fetch(url)
                    .then(status => { if (!status.ok) { throw Error(status) } return status })
                    .then(response => response.json())
                    .then(manifest => {
                        let metadataMap = new Map()
                        manifest.metadata?.forEach(dat => {
                            metadataMap.set(dat.label, Array.isArray(dat.value) ? dat.value.join(", ") : dat.value)
                            if (DLA_FIELDS.includes(dat.label)) {
                                dl += `<dt>${dat.label}</dt><dd>${metadataMap.get(dat.label)}</dd>`
                            }
                            if (DLA_FILTERS[dat.label]) {
                                r.setAttribute("data-" + DLA_FILTERS[dat.label], metadataMap.get(dat.label))
                                let values = (Array.isArray(dat.value)) ? dat.value : [dat.value]
                                if (!dla_facets[DLA_FILTERS[dat.label]]) {
                                    dla_facets[DLA_FILTERS[dat.label]] = new Set()
                                }
                                for (const v of values) {
                                    dla_facets[DLA_FILTERS[dat.label]] = dla_facets[DLA_FILTERS[dat.label]].add(v.replace(/\?/g, ""))
                                }
                            }
                        })
                        r.setAttribute("data-query", DLA_SEARCH.reduce((a, b) => a += (metadataMap.has(b) ? metadataMap.get(b) : "*") + " ", ""))
                        r.querySelector("dl").innerHTML = dl
                    })
                    .catch(err => { throw Error(err) })
                )
            })
            document.getElementById("dla_query").addEventListener("input", filterQuery)
            return Promise.all(dla_loading).then(() => populateSidebar(dla_facets, DLA_FILTERS, "dla")).catch(err=>console.error(err))
        }

        /**
         * Render a filterable scrollable area to go over the status of each DLA item or each  T-PEN project
         * or possibly a combinations. 
         * */
        async function loadInterfaceTPEN() {
            let tpenAreaElem = document.getElementById("tpen_browsable")
            tpenAreaElem.innerHTML = `
                <div id="TPENDocuments" class="grow wrap">list loading</div>
                <div class="sidebar">
                    <h3>Refine Results <button role="button" id="tpenQueryReset">clear all</button></h3>
                    <progress value="107" max="107">107 of 107</progress>
                    <input id="tpen_query" type="text" placeholder="type to filter">
                    <section id="tpenFacetFilter"></section>
                </div>
            `
            const TPEN_FIELDS = [
                "title", "subtitle", "subject", "date", "language",
                "author", "description", "location"
            ]

            const TPEN_FILTERS = {
                Status: "status"
            }

            // const TPEN_FILTERS = {
            //     parsedStatus: "false", assignedStatus: "false", transcribedStatus:"false",
            //     finalizedStatus: "false", TPENLinkStatus:"false", describedStatus:"false"
            // }

            const TPEN_SEARCH = [
                "title", "subtitle", "subject", "date", "language",
                "author", "description", "location"
            ]

            const statusesToFind = [
                "parsedStatus",
                "assignedStatus",
                "transcribedStatus",
                "finalizedStatus",
                "TPENLinkStatus",
                "describedStatus"
            ]

            document.getElementById("TPENDocuments").innerHTML = ""
            let TPENProjectListElem = ``
            for(proj of tpenProjects){
                //Each thing will have this suite of statuses to check for
                //These are in the tpen objects
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateProjectStatusElement(status, proj)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                document.getElementById("TPENDocuments").innerHTML += `
                    <div class="tpenRecord record" data-id="${tpenProjectPrefix+proj.id}" data-status="${statusListAttributes.join(" ")}">
                    <h3><a href="${tpenProjectPrefix+proj.id}">${proj["metadata_name"]}</a></h3>
                    <div class="row">
                        <dl>
                        </dl>
                    </div>
                    <div class="row">
                        <dl>
                            ${statusListElements}
                        </dl>
                    </div>
                </div>
                `
            }

            tpenRecords = document.querySelectorAll(".tpenRecord")
            let tpen_loading = []
            let statusSet = new Set();
            statusSet.add("parsedStatus")
            statusSet.add("assignedStatus")
            statusSet.add("transcribedStatus")
            statusSet.add("finalizedStatus")
            statusSet.add("TPENLinkStatus")
            statusSet.add("describedStatus")
            let tpen_facets = {
                "status":statusSet
            }
            Array.from(tpenRecords).forEach(r => {
                const url = r.getAttribute("data-id")
                let dl = ``
                tpen_loading.push(fetch(url)
                    .then(status => { if (!status.ok) { throw Error(status) } return status })
                    .then(response => response.json())
                    .then(tpenProject => {
                        let metadataMap = new Map()
                        tpenProject.metadata?.forEach(dat => {
                            metadataMap.set(dat.label, Array.isArray(dat.value) ? dat.value.join(", ") : dat.value)
                            if (TPEN_FIELDS.includes(dat.label)) {
                                //dl += `<dt>${dat.label}</dt><dd>${metadataMap.get(dat.label)}</dd>`// many of these are blank...
                                if(metadataMap.get(dat.label).trim() !== ""){
                                    dl += `<dt>${dat.label}</dt><dd>${metadataMap.get(dat.label)}</dd>`
                                }
                            }
                        })
                        //Here we aren't filtering by metadata.  We are filtering by statuses, it is the only facet and is set above
                        r.setAttribute("data-query", TPEN_SEARCH.reduce((a, b) => a += (metadataMap.has(b) ? metadataMap.get(b) : "*") + " ", ""))
                        r.querySelector("dl").innerHTML = dl
                    })
                    .catch(err => { throw Error(err) })
                )
            })
            document.getElementById("tpen_query").addEventListener("input", filterQuery)
            return Promise.all(tpen_loading).then(() => populateSidebar(tpen_facets, TPEN_FILTERS, "tpen")).catch(err=>console.error(err))
        }

        function populateSidebar(facets, filters, which) {
            //The facet needs to be <facet data-facet="status" data-label="parsedStatus" data-count="1"> for each status to filter by.
            let side = `<ul>`
            let elemRoot = document.getElementById(which+"_browsable")
            for (const f in filters) {
                if (!facets[filters[f]]) continue
                side += `<li>${f}</li>`
                side += Array.from(facets[filters[f]]).reduce((a, b) => a += `<facet data-facet="${filters[f]}" data-label="${b}">${b}</facet>`, ``)
            }
            side += `</ul>`
            let facetFilter = document.getElementById(which+"FacetFilter")
            facetFilter.innerHTML = side
            let facetsElements = elemRoot.querySelectorAll("[data-facet]")
            Array.from(facetsElements).forEach(el => el.addEventListener("click", filterFacets))
            updateCount(which)
            loadQuery(which)
        }

        function updateCount(which) {
            // let visibleCount = Array.from(records).filter(el=>el.offsetParent === null).length
            let elemRoot = document.getElementById(which+"_browsable")
            let records = document.getElementsByClassName("."+which+"Record")
            let hiddenCount = elemRoot.querySelectorAll(".record[class*='hide-']").length
            let queryInput = document.getElementById(which+"_query")
            let countBar = queryInput.previousElementSibling
            let countBarValue = records.length - hiddenCount
            countBar.max = records.length
            countBar.textContent = countBarValue + " of " + countBar.max
            if(progress != undefined){
               clearInterval(progress) 
            }
            const notzero = countBarValue > countBar.value ? 1 : -1
            let step = parseInt((countBarValue - countBar.value) / 25) || notzero
            progress = setInterval(() => {
                countBar.value += step
                if (Math.abs(countBar.value - countBarValue) < 2) {
                    countBar.value = countBarValue
                    clearInterval(progress)
                }
            }, 10)
            let facetsElements = elemRoot.querySelectorAll("facet")
            Array.from(facetsElements).forEach(f => {
                const k = f.getAttribute("data-facet")
                const v = f.textContent
                let count = elemRoot.querySelectorAll(".record:not([class*='hide-'])[data-" + k + "*='" + v + "']").length
                f.setAttribute("data-count", count)
                // if (count === 0) {
                //     f.classList.add("hide-sidebar")
                // } else {
                //     f.classList.remove("hide-sidebar")
                // }
            })
        }

        const loadQuery = (which) => {
            const params = new URLSearchParams(location.search)
            let queryInput = document.getElementById(which+"_query")
            let elemRoot = document.getElementById(which+"_browsable")
            params.forEach((v,k)=>{
                elemRoot.querySelectorAll(`[data-facet="${k}"][data-label="${v}"]`)
                 .forEach(el=>el.click())
            })
            const queryString = params.get("q")

            if(queryString){
                queryInput.value = queryString
                queryInput.dispatchEvent(new Event('input'))
            }
        }

        if (window.tpenQueryReset) {
            tpenQueryReset.addEventListener("click", ev => {
                Array.from(document.getElementById("tpen_browsable").querySelectorAll(".clicked")).forEach(el => el.dispatchEvent(new Event("click")))
                document.getElementById("tpen_query").value = ""
                document.getElementById("tpen_query").dispatchEvent(new Event("input"))
            })
        }

        if (window.dlaQueryReset) {
            dlaQueryReset.addEventListener("click", ev => {
                Array.from(document.getElementById("dla_browsable").querySelectorAll(".clicked")).forEach(el => el.dispatchEvent(new Event("click")))
                document.getElementById("dla_query").value = ""
                document.getElementById("dla_query").dispatchEvent(new Event("input"))
            })
        }

        function filterQuery(event) {
            const queryString = event.target.value
            let which = event.target.id.replace("_query","")
            let records = document.getElementsByClassName("."+which+"Record")
            Array.from(records).forEach(r => new RegExp(queryString, "i").test(r.getAttribute("data-query")) ? r.classList.remove("hide-query") : r.classList.add("hide-query"))
            //Manuscripts.querySelectorAll(".record:not([data-query*='"+queryString+"'])")
            updateCount(which)
        }
        function filterFacets(event) {
            let which = event.target.closest("section").id.replace("FacetFilter", "")
            const clicked = event.target
            clicked.classList.toggle("clicked")
            const action = clicked.classList.contains("clicked") ? "add" : "remove"
            const k = clicked.getAttribute("data-facet")
            const v = clicked.textContent
            let records = document.getElementsByClassName("."+which+"Record")
            Array.from(records).forEach(r => { if (!new RegExp(v, "i").test(r.getAttribute("data-" + k))) r.classList[action]("hide-facet") })
            updateCount(which)
        }
    </script>
</body>
</html>
