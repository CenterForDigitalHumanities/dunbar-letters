<!DOCTYPE html>
<html lang="en">

<head>
    <title>Dunbar Letters Status</title>
    <!-- <link rel="stylesheet" href="css/gloss.css"> -->
    <link rel="stylesheet" href="css/status.css">
    <link href="favicon.ico" rel="icon" type="image/x-icon" />
    <style>

        .good{
            color: green;
            font-weight: bold;
        }

        .bad{
            color: red;
            font-weight: bold;
        }

        .statusLabel{

        }

        .tpenProjectStatus{

        }

        .tpenProjectStatusList{

        }

        #tpen_browsable, #dla_browsable{
            display : none;
        }

    </style>
</head>

<body class="container">
    <gm-header>
        <div class="tabs">
            <a href="./index.html">üè†</a>
            <a href="./manuscripts.html">üìö View Manuscripts</a>
            <a href="./ms.html" id="thisMS" class="is-hidden">üìñ This Manuscript</a>
        </div>
    </gm-header>

    <div class="itemStatusRenderingExample">
        <input type="button" value="TPEN Project Statuses" onclick="determineStatusesAgainstTPENProjects()" />
        <input type="button" value="UDel Record Statuses" onclick="determineStatusesAgainstDLARecords()" />
        <input type="button" value="Load Filterable Interface" onclick="loadInterface()" />
        <div id="tpenProjectsStatusArea"> </div>
        <div id="dlaRecordsStatusArea"> </div>
    </div>

    <div id="dla_browsable" class="container reverse">
        <div id="Documents" class="grow wrap">list loading</div>
        <div class="sidebar">
            <h3>Refine Results <button role="button" id="queryReset">clear all</button></h3>
            <progress value="107" max="107">107 of 107</progress>
            <input id="query" type="text" placeholder="type to filter">
            <section id="dlaFacetFilter"></section>
        </div>
    </div>

    <div id="tpen_browsable" class="container reverse hidden">
        <div id="Documents" class="grow wrap">list loading</div>
        <div class="sidebar">
            <h3>Refine Results <button role="button" id="queryReset">clear all</button></h3>
            <progress value="107" max="107">107 of 107</progress>
            <input id="query" type="text" placeholder="type to filter">
            <section id="tpenFacetFilter"></section>
        </div>
    </div>

    <gm-footer>
        <a href="./index.html">üè†</a>
        <a href="./manuscripts.html">üìö</a>
        <a rel="noopener noreferrer" title="View on GitHub" href="https://github.com/cubap/Dunbar-Letters"
            target="_blank">
            <svg height="16" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="16"
                aria-hidden="true">
                <path fill-rule="evenodd"
                    d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
                </path>
            </svg>
        </a>
    </gm-footer>
    
    <div id="globalFeedback" class="card is-center"></div>
    <script src="js/deer.js" type="module"></script>
    <script src="js/app.js" type="module"></script>
    <script>
        let tpenProjects = []
        let dlaCollection = []
        const udelHandlePrefix = "https://udspace.udel.edu/rest/handle/"
        const udelIdPrefix = "https://udspace.udel.edu/rest/items/"
        const tpenProjectPrefix = "https://t-pen.org/TPEN/project/"
        const TPproxy = "http://tinypaul.rerum.io/dla/proxy?url="

        getTranscriptionProjects()
        fetchLetters()

        /**
         * Hey internet, I want the Dunbar Projects out of T-PEN.
         * */
        async function getTranscriptionProjects(){
            tpenProjects =  
            await fetch(`media/tpenShort.json`)
            //await fetch(`http://165.134.105.25:8181/TPEN28/getDunbarProjects`)
            .then(res=>res.ok?res.json():[])
            .then(projects=>{return projects})
            .catch(err=> {
                console.error(err)
                return []
            })
        }

        /**
         * Hey internet, I want the DLA items from Delaware.
         * */
        async function fetchLetters() {
            dlaCollection = await fetch(`media/udelShort.json`)
                .then(res => res.ok ? res.json() : [])
                .then(records => {return records})
                .catch(err=> {
                    console.error(err)
                    return []
                })
        }

        function broadcast(event = {}, type, element, obj = {}) {
            let e = new CustomEvent(type, { detail: Object.assign(obj, { target: event.target }), bubbles: true })
            element.dispatchEvent(e)
        }

        /**
         * Generate the HTML element which will represent the status passed in.  
         * This is for the T-PEN projects items.
         * */
        async function generateProjectStatusElement(status){
            let el, statusString, Fcode = ""
            let linkingAnnos, describingAnnos = []
            //Each status handled as its own case.  If we are uniform in what we do we can make this part much shorter if we have a strategic statusesToFind
            switch (status){
                case "parsedStatus":
                    statusString = "<span class='statusString good'>Parsed</span>"
                    proj.pages.forEach(page => {
                        if(page.numParsedLines < 5){
                            statusString = "<span title='See "+page.page_name+"' class='statusString bad'>Not Parsed</span>"
                            return
                        }
                    })
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title="Check if there are more than 5 lines with width > 0"> TPEN Project Parsed </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`                               
                break
                case "assignedStatus":
                    statusString = `<span class='statusString bad'>Not Assigned</span>`
                    if(proj.assignees.length > 2){
                        statusString = `<span class='statusString good'>Assigned to ${proj.assignees.length} users </span>`
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title="Check if it is assigned to at least 1 user"> TPEN Project Assigned </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`   
                break
                case "transcribedStatus":
                    statusString = "<span class='statusString good'>Transcribed</span>"
                    proj.pages.forEach(page => {
                        //We really need to think about this one.
                        if(page.numTranscribedLines < 5){
                            statusString = "<span title='See "+page.page_name+"' class='statusString bad'>Not Transcribed</span>"
                            return
                        }
                    })
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title="Check if there are more than 5 lines with width > 0 that have text on each page"> TPEN Project Transcribed </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`   
                break
                case "finalizedStatus":
                    statusString = "<span class='statusString bad'>Not Finalized</span>"
                    if(proj.finalized === "true"){
                        statusString = "<span class='statusString good'>Finalized</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title="If there are more than 5 parsed lines on each page, and every line contains text.  Logic performed in servlet and returns T/F."> TPEN Project Finalized </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`   
                break
                case "TPENLinkStatus":
                    linkingAnnos = await fetchQuery({"type":"Annotation", "tpenProject":""+proj.id})
                    statusString = "<span class='statusString bad'>No Linked Record</span>"
                    if(linkingAnnos.length>0){
                        statusString = "<span class='statusString good'> "+linkingAnnos.length+" Linked Record(s)</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title=""> Linked to UDel Data </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`   
                break
                case "describedStatus":
                    //This T-PEN project would have to be linked to a UDEL record
                    //That linking annotation has a target
                    //If it is described, other annos will target that same target
                    //Check how many annos target, and define the good/bad threshold. 

                    //So there are some testing ones around.  Look for tpenProject.
                    linkingAnnos = await fetchQuery({"type":"Annotation", "tpenProject":""+proj.id})
                    describingAnnos = []
                    if(linkingAnnos.length > 0){
                        describingAnnos = await fetchQuery({"type":"Annotation", "target":linkingAnnos[0].target})
                    }
                    //Grabbing to anno.targets will tell you what handle
                    statusString = "<span class='statusString bad'>Not Described</span>"
                    if(describingAnnos.length>0){
                        statusString = "<span class='statusString good'>There are "+describingAnnos.length+" descriptive annotations</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel" title=""> Well Described </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`   
                break
                default:
                    el=""
                    console.error("Uknown status "+status)
            }
            return el
        }

        /**
         * Generate the HTML element which will represent the status passed in.  
         * This is for the DLA items.
         * */
        async function generateDLAStatusElement(status){
            let statusString = ""
            switch (status){
                case "TPENProjectCreated":
                    //Can we match a T-PEN project to this record?
                    statusString = "<span class='statusString bad'>No TPEN Project Created</span>"
                    let found = await matchTranscriptionRecords(item)
                    if(found.length > 0){
                        statusString = "<span title='"+found.join()+"' class='statusString good'>"+found.length+" TPEN Projects Found</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> TPEN Transcription Project Created </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "TPENProjectLinked":
                    const tpenProjectKeyWildcard = {$exists: true, $type: 'string', $ne: ''}
                    statusString = "<span class='statusString bad'>No TPEN Link</span>"
                    let tpenProjectLinkingAnnos = await fetchQuery({"type":"Annotation", "target":udelHandlePrefix+item.handle, "body.tpenProject":tpenProjectKeyWildcard})
                    let tpenProjectIDs = []
                    if(tpenProjectLinkingAnnos.length > 0){
                        for(tpenAnno of tpenProjectLinkingAnnos){
                            tpenProjectIDs.push(tpenProjectLinkingAnnos.body.tpenProject)
                        }
                        statusString = "<span title='See "+tpenProjectIDs.join()+"' class='statusString good'>Found TPEN Project Link(s)</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> T-PEN Project Linked Status </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "envelopeLinked":
                    //This is probably a T-PEN check, not sure. Can we check for an annotation with body that is a certain name or a primitive name of some kind?
                    statusString = "<span class='statusString good'>Under Development!</span>"
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> Item Envelope </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                case "uDelLinked":
                    statusString = "<span class='statusString bad'>Record Not Linked</span>"
                    let recordHandleAnnos2 = await fetchQuery({"type":"Annotation", "body.source.value":udelHandlePrefix+item.handle})
                    if(recordHandleAnnos2.length > 0){
                        statusString = "<span title='See "+recordHandleAnnos2[0].target+"' class='statusString good'>Record Linked</span>"
                    }
                    el =
                    `<li which="${status}">
                        <label class="statusLabel"> RERUM Record Linked Status </label>
                        <div class="statusValue">${statusString}</div>
                    </li>`
                break
                default:
                    el=``
                    console.error("Uknown status "+status)
            }
            return el
        }

        /**
         * Loop through all DLA records and determine the following statuses:
         * "uDelLinked",
         * "TPENProjectCreated"
         * "TPENProjectLinked"
         * "envelopeLinked"
         * */
        async function determineStatusesAgainstDLARecords(){
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            const statusesToFind = [
                "uDelLinked",
                "TPENProjectCreated",
                "TPENProjectLinked",
                "envelopeLinked"
            ]
            let handle = dlaCollection.handle
            let collectionID = dlaCollection.id
            let collectionName = dlaCollection.name
            let numItems = dlaCollection?.items.length
            let dlaRecordsHeading = `<h2>${collectionName} Records</h2><p>There are ${numItems} records.  Here are their details.</p>`
            document.getElementById("dlaRecordsStatusArea").innerHTML += dlaRecordsHeading
            for (item of dlaCollection.items){
                let item_handle = item.handle
                let item_id = item.id
                let item_name = item.name
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateDLAStatusElement(status)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                //Can filter items by statuses in status-list
                let itemArea = `
                    <div class="dlaItemStatus" status-list="${statusListAttributes.join(' ')}">
                        <h3>${item_id+": "+item_name}</h3>
                        <ul class="dlaItemStatusList">${statusListElements}</ul>
                    </div>
                `
                document.getElementById("dlaRecordsStatusArea").innerHTML += itemArea
            }
        }

        /**
         * Loop through all the Dunbar T-PEN projects and determine the following statuses
         * "parsedStatus"
         * "assignedStatus"
         * "transcribedStatus"
         * "finalizedStatus"
         * "TPENLinkStatus"
         * "describedStatus"
         * */
        async function determineStatusesAgainstTPENProjects(){
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            const statusesToFind = [
                "parsedStatus",
                "assignedStatus",
                "transcribedStatus",
                "finalizedStatus",
                "TPENLinkStatus",
                "describedStatus"
            ]
            //Go over each TPEN project and figure out the status stats.
            let numItems = tpenProjects.length
            let dlaRecordsHeading = `<h2>Dunbar Projects in T-PEN</h2><p>There are ${numItems} records.  Here are their details.</p>`
            document.getElementById("tpenProjectsStatusArea").innerHTML += dlaRecordsHeading
            for(proj of tpenProjects){
                //Each thing will have this suite of statuses to check for
                //These are in the tpen objects
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateProjectStatusElement(status)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                let projectArea = `
                    <div class="tpenProjectStatus" status-list="${statusListAttributes.join(' ')}">
                        <h3>${proj.id+": "+proj.project_name+" ("+proj.metadata_name+")"}</h3>
                        <ul class="tpenProjectStatusList">${statusListElements}</ul>
                    </div>
                `
                document.getElementById("tpenProjectsStatusArea").innerHTML += projectArea
            }
        }

        /**
         * Determine all statuses possible against the dataset, and put them together in a meaningful way.
         * */
        async function statuses(){
            console.warn("Not Yet :(")
            document.getElementById("dlaRecordsStatusArea").innerHTML = ""
            document.getElementById("tpenProjectsStatusArea").innerHTML = ""
        }


        /**
         * Perform a tiny query against the query parameter object passed in.
         * */
        async function fetchQuery(params){
            const historyWildcard = { $exists: true, $type: 'array', $eq: [] }
            let query = {
                "__rerum.history.next": historyWildcard
            }
            let queryObj = Object.assign(query, params)
            return fetch("http://tinydev.rerum.io/app/query", {
                method: 'POST',
                mode: 'cors',
                body: JSON.stringify(queryObj)
            })
            .then(res => res.ok ? res.json() : Promise.reject(res))
        }

        /**
         *  You have a DLA Item F-Code known from a project ID.  Get the DLA record(s) that have a matching F-Code in their metadata.
         * */
        async function findUdelRecordWithCode(Fcode, projID) {
            // This is the Fcode that the TPEN project knew, like F158
            // Need to check that there is a udel item with this Fcode, looking through letters collection.
            const getFolderFromMetadata = (metaMap) => {
                let ok = false
                for (const m of metaMap) {
                    if (m.key === "dc.identifier.other") { 
                        ok = true
                        return m.value 
                    }
                }
                if(!ok){
                    console.error("No dc.identifier.other in metadata")
                    console.log(metaMap)
                }
            }
            let match = false
            let impossible = false;
            let itemHandle = ""
            for(item of dlaCollection.items){
                const metadataUri = `http://tinypaul.rerum.io/dla/proxy?url=${udelHandlePrefix+item.handle}?expand=metadata`    
                match = await fetch(metadataUri)
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(meta => getFolderFromMetadata(meta.metadata))
                    .then(folderString => {
                        if(folderString !== undefined && folderString.indexOf(" F") > -1){
                            return folderString.split(" F").pop()
                        }
                        else{
                            //This DLA item does not have dc.identifier.other, so there is no connected Fcode
                            impossible = true
                            return ""
                        }
                    }) // Like "Box 3, F4"
                    .then(folderNumber => {
                        const matchStr = `F${folderNumber.padStart(3, '0')}`
                        return Fcode === matchStr
                    })
                if(match){
                    itemHandle = udelHandlePrefix+item.handle
                    return
                }    
                if(impossible){
                    console.error("Could not determine folder name for "+udelHandlePrefix+item.handle+"?expand=metadata.  That means this TPEN project "+projID+" cannot determine if a udel record exists for code "+Fcode+".  We are skipping the check for this project.")
                    return
                }
            }
            return itemHandle
        }

        /**
         * You have a DLA record.  You would like to see if any transcription projects are created that are about this record.
         * Note this does not detect that record and project(s) are specifically linked yet.
         * */
        async function matchTranscriptionRecords(dlaRecord) {
            const metadataUri = `http://tinypaul.rerum.io/dla/proxy?url=${udelHandlePrefix+dlaRecord.handle}?expand=metadata`
            return await fetch(metadataUri)
                .then(res => res.ok ? res.json() : Promise.reject(res))
                .then(meta => getFolderFromMetadata(meta.metadata))
                .then(folderString => folderString.split(" F").pop()) // Like "Box 3, F4"
                .then(folderNumber => {
                    const matchStr = `F${folderNumber.padStart(3, '0')}`
                    let matches = []
                    for (const f of tpenProjects) {
                        if (f.collection_code === matchStr) { 
                            matches.push(f.id) 
                        }
                    }
                    return matches
                })
                .catch(err => {return []})
        }

        /**
         * Render a filterable scrollable area to go over the status of each DLA item or each  T-PEN project
         * or possibly a combinations. 
         * */
        function loadInterfaceDLA(dlaItems) {
            let dlaAreaElem = document.getElementById("dla_browsable")
            
            dlaAreaElem.innerHTML = `
                <div id="DLADocuments" class="grow wrap">list loading</div>
                <div class="sidebar">
                    <h3>Refine Results <button role="button" id="dlaQueryReset">clear all</button></h3>
                    <progress value="107" max="107">107 of 107</progress>
                    <input id="query" type="text" placeholder="type to filter">
                    <section id="dlaFacetFilter"></section>
                </div>
            `

            //Example Metadata
            let exampleMet = [
                {
                "key": "dc.contributor.author",
                "value": "Dunbar-Nelson, Alice",
                "language": ""
                },
                {
                "key": "dc.date.accessioned",
                "value": "2021-02-12T16:58:45Z",
                "language": ""
                },
                {
                "key": "dc.date.available",
                "value": "2021-02-12T16:58:45Z",
                "language": ""
                },
                {
                "key": "dc.date.issued",
                "value": "[1898-09-18]",
                "language": ""
                },
                {
                "key": "dc.identifier.other",
                "value": "Box 3, F77",
                "language": ""
                },
                {
                "key": "dc.identifier.uri",
                "value": "https://udspace.udel.edu/handle/19716/28704",
                "language": ""
                },
                {
                "key": "dc.format.extent",
                "value": "4 pages",
                "language": ""
                },
                {
                "key": "dc.language.iso",
                "value": "en_US",
                "language": "en_US"
                },
                {
                "key": "dc.publisher",
                "value": "University of Delaware Library. Special Collections",
                "language": "en_US"
                },
                {
                "key": "dc.rights",
                "value": "Use of materials from this collection beyond the exceptions provided for in the Fair Use and Educational Use clauses of the U.S. Copyright Law may violate federal law. Permission to publish or reproduce is required from the copyright holder. Please contact Special Collections Department, University of Delaware Library, https://library.udel.edu/static/purl.php?askspec",
                "language": ""
                },
                {
                "key": "dc.subject",
                "value": "Dunbar-Nelson, Alice Moore, 1875-1935",
                "language": "en_US"
                },
                {
                "key": "dc.subject",
                "value": "Dunbar, Paul Laurence, 1872-1906",
                "language": "en_US"
                },
                {
                "key": "dc.subject",
                "value": "African American authors--20th century",
                "language": "en_US"
                },
                {
                "key": "dc.subject",
                "value": "Correspondence.",
                "language": "en_US"
                },
                {
                "key": "dc.title",
                "value": "West Medford, Mass. Alice to Paul. Autograph letter signed",
                "language": "en_US"
                },
                {
                "key": "dc.identifier.collection",
                "value": "MSS 0113",
                "language": ""
                },
                {
                "key": "dc.identifier.unique",
                "value": "OCLC # 587446079",
                "language": ""
                }
            ]

            const DLA_FIELDS = [
                "Name", "Item Handle", "Item ID"
                //"Author", "Subjects", "Publisher", "Language", 
                //"Date Issued", "Box ID", "Number of Pages",
                //"Collection ID", "Unique ID"
                // script, decoration, physical description
            ]

            const DLA_FILTERS = {
                Status: "statuses"
            }


            const DLA_SEARCH =[
                "Title", "Physical Description", "Note(s)", "Region",
                "Topic", "Subject", "Repository", "Call Number", "Is Part Of"
            ]

            let listOfDLAItems = dlaItems.reduce((a, b) => {
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateDLAStatusElement(status)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                a += `
                <div class="dlaRecord" data-id="${TPproxy+udelIdPrefix+b.id}?expand=metadata" statuses="${statusListAttributes.join(" ")}">
                    <h4><a href="${udelIdPrefix+b.id}">${b.name}</a></h4>
                    <ul>
                        ${statusListElements}
                    </ul>
                </div>`}, ``)

            dlaAreaElem.innerHTML = listOfDLAItems

            let dlaRecords = document.querySelectorAll(".dlaRecord")
            let dla_facets = {}
            let dla_loading = []

            Array.from(dlaRecords).forEach(r => {
                const url = r.getAttribute("data-id")
                let dl = ``
                dla_loading.push(fetch(url)
                    .then(status => { if (!status.ok) { throw Error(status) } return status })
                    .then(response => response.json())
                    .then(manifest => {
                        let metadataMap = new Map()
                        manifest.metadata?.forEach(dat => {
                            metadataMap.set(dat.label, Array.isArray(dat.value) ? dat.value.join(", ") : dat.value)
                            if (DLA_FIELDS.includes(dat.label)) {
                                dl += `<dt>${dat.label}</dt><dd>${metadataMap.get(dat.label)}</dd>`
                            }
                            if (DLA_FILTERS[dat.label]) {
                                r.setAttribute("data-" + DLA_FILTERS[dat.label], metadataMap.get(dat.label))
                                let values = (Array.isArray(dat.value)) ? dat.value : [dat.value]
                                if (!dla_facets[DLA_FILTERS[dat.label]]) {
                                    dla_facets[DLA_FILTERS[dat.label]] = new Set()
                                }
                                for (const v of values) {
                                    dla_facets[DLA_FILTERS[dat.label]] = dla_facets[DLA_FILTERS[dat.label]].add(v.replace(/\?/g, ""))
                                }
                            }
                        })
                        r.setAttribute("data-query", DLA_SEARCH.reduce((a, b) => a += (metadataMap.has(b) ? metadataMap.get(b) : "*") + " ", ""))
                        r.querySelector("dl").innerHTML = dl
                    })
                    .catch(err => { throw Error(err) })
                )
            })

            query.addEventListener("input", filterQuery)
            return Promise.all(dla_loading).then(() => populateSidebar(dla_facets, DLA_FILTERS, "dla")).catch(err=>console.error(err))
        }

        /**
         * Render a filterable scrollable area to go over the status of each DLA item or each  T-PEN project
         * or possibly a combinations. 
         * */
        function loadInterfaceTPEN(transcriptionProjects) {
            let tpenAreaElem = document.getElementById("tpen_browsable")
            tpenAreaElem.innerHTML = `
                <div id="TPENDocuments" class="grow wrap">list loading</div>
                <div class="sidebar">
                    <h3>Refine Results <button role="button" id="tpenQueryReset">clear all</button></h3>
                    <progress value="107" max="107">107 of 107</progress>
                    <input id="query" type="text" placeholder="type to filter">
                    <section id="tpenFacetFilter"></section>
                </div>
            `
            const TPEN_FIELDS = [
                "Project Name", "Alternate Name", "Number of Pages", "Assigness",
                "Is Finalized", "Collection Code", "T-PEN Project ID"
            ]

            const TPEN_FILTERS = {
                Status: "stauses"
            }

            const TPEN_SEARCH = [
                "Title", "Physical Description", "Note(s)", "Region",
                "Topic", "Subject", "Repository", "Call Number", "Is Part Of"
            ]

            let listOfTPENprojects = transcriptionProjects.reduce((a, b) => {
                let statusListElements = ``
                let statusListAttributes = new Array()
                for(status of statusesToFind){
                    let el = await generateProjectStatusElement(status)
                    if(el.indexOf("statusString good")>-1){
                        statusListAttributes.push(status)
                    }
                    statusListElements += el
                }
                a += `
                <div class="dlaRecord" data-id="${tpenProjectPrefix+b.id}" statuses="${statusListAttributes.join(" ")}">
                    <h4><a href="${udelIdPrefix+b.id}">${b.name}</a></h4>
                    <ul>
                        ${statusListElements}
                    </ul>
                </div>`}, ``)
            tpenAreaElem.innerHTML = listOfTPENprojects

            let tpenRecords = document.querySelectorAll(".tpenRecord")
            let tpen_facets = {}
            let tpen_loading = []

            Array.from(tpenRecords).forEach(r => {
                const url = r.getAttribute("data-id")
                let dl = ``
                tpen_loading.push(fetch(url)
                    .then(status => { if (!status.ok) { throw Error(status) } return status })
                    .then(response => response.json())
                    .then(manifest => {
                        let metadataMap = new Map()
                        manifest.metadata?.forEach(dat => {
                            metadataMap.set(dat.label, Array.isArray(dat.value) ? dat.value.join(", ") : dat.value)
                            if (TPEN_FIELDS.includes(dat.label)) {
                                dl += `<dt>${dat.label}</dt><dd>${metadataMap.get(dat.label)}</dd>`
                            }
                            if (TPEN_FILTERS[dat.label]) {
                                r.setAttribute("data-" + TPEN_FILTERS[dat.label], metadataMap.get(dat.label))
                                let values = (Array.isArray(dat.value)) ? dat.value : [dat.value]
                                if (!tpen_facets[TPEN_FILTERS[dat.label]]) {
                                    tpen_facets[TPEN_FILTERS[dat.label]] = new Set()
                                }
                                for (const v of values) {
                                    tpen_facets[TPEN_FILTERS[dat.label]] = tpen_facets[FILTERS[dat.label]].add(v.replace(/\?/g, ""))
                                }
                            }
                        })
                        r.setAttribute("data-query", TPEN_SEARCH.reduce((a, b) => a += (metadataMap.has(b) ? metadataMap.get(b) : "*") + " ", ""))
                        r.querySelector("dl").innerHTML = dl
                    })
                    .catch(err => { throw Error(err) })
                )
            })
            query.addEventListener("input", filterQuery)
            return Promise.all(dla_loading).then(() => populateSidebar(tpen_facets, TPEN_FILTERS, "tpen")).catch(err=>console.error(err))
        }

        function populateSidebar(facets, filters, which) {
            let side = `<ul>`
            for (const f in FILTERS) {
                if (!facets[FILTERS[f]]) continue
                side += `<li>${f}</li>`
                side += Array.from(facets[FILTERS[f]]).reduce((a, b) => a += `<facet data-facet="${filters[f]}" data-label="${b}">${b}</facet>`, ``)
            }
            side += `</ul>`
            let facetFilter = document.getElementById(which+"FacetFilter")
            facetFilter.innerHTML = side
            let facetsElements = document.querySelectorAll("[data-facet]")
            Array.from(facetsElements).forEach(el => el.addEventListener("click", filterFacets))
            updateCount()
            loadQuery()
        }

        function updateCount() {
            // let visibleCount = Array.from(records).filter(el=>el.offsetParent === null).length
            let hiddenCount = document.querySelectorAll(".record[class*='hide-']").length
            let countBar = query.previousElementSibling
            let countBarValue = records.length - hiddenCount
            countBar.max = records.length
            countBar.textContent = countBarValue + " of " + countBar.max
            clearInterval(progress)
            const notzero = countBarValue > countBar.value ? 1 : -1
            let step = parseInt((countBarValue - countBar.value) / 25) || notzero
            progress = setInterval(() => {
                countBar.value += step
                if (Math.abs(countBar.value - countBarValue) < 2) {
                    countBar.value = countBarValue
                    clearInterval(progress)
                }
            }, 10)
            let facetsElements = document.querySelectorAll("facet")
            Array.from(facetsElements).forEach(f => {
                const k = f.getAttribute("data-facet")
                const v = f.textContent
                let count = document.querySelectorAll(".record:not([class*='hide-'])[data-" + k + "*='" + v + "']").length
                f.setAttribute("data-count", count)
                if (count === 0) {
                    f.classList.add("hide-sidebar")
                } else {
                    f.classList.remove("hide-sidebar")
                }
            })
        }

        const loadQuery = () => {
            const params = new URLSearchParams(location.search)
            params.forEach((v,k)=>{
                document.querySelectorAll(`[data-facet="${k}"][data-label="${v}"]`)
                 .forEach(el=>el.click())
            })
            const queryString = params.get("q")
            if(queryString){
                query.value = queryString
                query.dispatchEvent(new Event('input'))
            }
        }

        if (window.tpenQueryReset) {
            tpenQueryReset.addEventListener("click", ev => {
                Array.from(document.querySelectorAll(".clicked")).forEach(el => el.dispatchEvent(new Event("click")))
                query.value = ""
                query.dispatchEvent(new Event("input"))
            })
        }

        if (window.dlaQueryReset) {
            dlaQueryReset.addEventListener("click", ev => {
                Array.from(document.querySelectorAll(".clicked")).forEach(el => el.dispatchEvent(new Event("click")))
                query.value = ""
                query.dispatchEvent(new Event("input"))
            })
        }

        function filterQuery(event) {
            const queryString = event.target.value
            Array.from(records).forEach(r => new RegExp(queryString, "i").test(r.getAttribute("data-query")) ? r.classList.remove("hide-query") : r.classList.add("hide-query"))
            //Manuscripts.querySelectorAll(".record:not([data-query*='"+queryString+"'])")
            updateCount()
        }
        function filterFacets(event) {
            const clicked = event.target
            clicked.classList.toggle("clicked")
            const action = clicked.classList.contains("clicked") ? "add" : "remove"
            const k = clicked.getAttribute("data-facet")
            const v = clicked.textContent
            Array.from(records).forEach(r => { if (!new RegExp(v, "i").test(r.getAttribute("data-" + k))) r.classList[action]("hide-facet") })
            updateCount()
        }
    </script>
</body>
</html>
